#뷰

- 뷰는 가상테이블로 물리적으로 규현되지 않는다
- 하나의 뷰를 삭제하면 그 뷰를 기초로하는 뷰도 자동 삭제됨
- 필요한 데이터만 뷰로 정의해서 처리하여 관리가 용이함
- 변경이 안되서 지우고 다시 만들어야함
- sql에서 create문을 사용한다? ㅇㅇ
- 실제 데이터가 저장되는거 아님


#이진 검색 알고리즘

- 피보나치 수열에 따른 방법이 아니다 (이는 피보나치 검색)
- 탐색 효율이 좋고 탐색 시간이 적게 소요
- 데이터가 정렬되어 있어야 한다
- 비교 회수가 증가할때 마다 데이터의 수가 절반

#선택정렬
- 하나하나 모두 비교 

#로킹기법
- 로킹은 하나의 트랜잭션이 데이터를 액세스 하는 동안 다른 트랜잭션이 그 데이터에 접속할 수 없도록 잠그는  것
- 로킹 단위가 크다 = 로크의 수가 적다 = 병행성 수준이 낮다
- 로킹 단위가 작다 = 로크의 수가 많다 = 병행성의 수준이 많다

#트랜잭션
- 데이터베이스의 상태를 변환시키기 위항 논리적 기능을 수행하는 하나의 작업 단위
- 한꺼번에 모두 수행 되어야 하는 일련의 연산집합
- 데베시스템에서 복구 및 병행 수행 시 처리되는 작업의 논리적 단위
- 하나의 트랜잭션은 커밋되거나 롤백된다
- 트랜잭션은 일반적으로 회복의 단위가 된다

특성

- 원자성 : 모두 반영되거나 전혀 반영되지 않아야 함 / 반드시 완벽하게 수행되거나 하나의 오류시 전체 취소
- 일관성 : 일관성 있는 상태로 변환해야함 / 고정 요소는 트랜잭션 전과 후 같아야함
- 독립성, 격리성 : 둘 이상의 트랜잭션이 동시에 발생할 경우 다른 연산에 끼어들 수 없다 / 수행중인 트랜잭션이 완료될 때 까지 다른 트랜잭션에서 결과를 참조할 수 없음
- 영속성, 지속성 : 성공적으로 완료된 트랜잭션은 영구적으로 반영되어야함


#관계대수 및 관계해석

관계대수

- 관계형 데베에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 언어
- 관계대수는 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어로 피연산자가 릴레이션 결과도 릴레이션
- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다
- 순수 관계 연산자 : select join project division
- 일반 집합 연산자 :합 교 차 집합


관계해석

- 코드가 수학의 술어 해석에 기반을 두고 관계 데이터베이스르르 위해 제안함
- 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성
- 원하는 저보를 정의할 때는 계산 수식을 사용한다
- 튜플 관계해석과 도메인 관계해석이 있다
- 기본적으로 관계해석과 관계대수는 관계 데베를 처리하는 기능과 능력면에서 동등하다
- 질의어로 표현한다


#데이터 베이스의 특징
- 실시간 접근성(Real-Time Accessibilty) : 실시간 처리 응답이 가능해야함
- 계속적인 변화(Continuous Evolution) : 새로운 데이터 삽입 삭제 갱신에서 항상 최신 데이터 유지
- 동시 공용(Concurrent Sharing) : 여러 사용자가 동시에 자기가 원하는 데이터를 이용할 수 있어야함
- 내용에 의한 참조(Content Reference) : 데이터 참조시 사용자가 요구하는 내용으로 데이터를 찾음

#이진 트리 운행법
- Preorder : root - left - right
- inorder : left - root -right
- Postorder - left - right - root

#릴레이션
- 데이터들을 표의 형태로 표현
- 개체 타입(Entity type) : 속성들로만 기술된 개체의 정의
- 개체 어커런스(Occurence) : 개체를 구성하고 있는 각 속성들이 값을 가져 하나의 개체를 나타내는 것 튜플과 같은 의미
- 튜플(Tuple) : 릴레이션을 구성하는 행 / 속성의 모임으로 구성 / 파일 구조에서 레코드와 같은 의미 / 카디날리티 = 튜플의 수 = 기수 = 대응 수
- 속성(애트리뷰트) : 데이터베이스를 구성하는 가장 작은 논리적 단위 / 파일 구조상의 데이터 항목 또는 데이터 필드에 해당 / 개체의 특성을 기술 / 디그리 속성의 수 = 차수
- 도메인 : 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자 값들의 집합 / 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데 이용

#분산 데이터베이스
장점

- 지역 자치성이 높다
- 효용성과 융통성이 높다
- 자료의 공유성이 향상
- 신뢰성 및 가용성
- 분산 제어가 가능
- 시스템 성능이 향상
- 점증적 시스템 용량 확장이 용의

단점

- DBMS가 수행할 기능이 복잡하다
- 처리비용이 중거헌더
- 데이터베이스 설계가 어렵다
- 잠재적 오류가 증가한다
- 소프트웨어 개발 비용이 증가한다

#시스템 카탈로그
- 시스템 가탈로그는 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다
- 시스템 카탈로그는 데이터베이스에 포함되는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다
- 데이터 정의어의 결과로 구성되는 기본테이블 뷰 인덱스 패키지 접근 권한 등의 데이터베이스 구조 및 통계 정보를 저장한다
- 카탈로그들이 생성되면 자료 사전에 저장되기 때문에 좁은 의미로는 카탈로그를 자료 사전이라고 한다
- 카탈로그에 저장된 정보를 메타 데이터라고 한다
- 시스템 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 사용자도 sql을 이용하여 검색이 가능하다
- 카탈로그를 갱신하는 것은 허용하지 않는다
-  dbms가 스스로 생성하고 유지한다

#데이터베이스 설계 순서
요구 분석 - 개념적 설계 - 논리적 설계 - 물리적 설계 - 데이터베이스 구현

- 개념적 설계 : 트랜잭션 모델링 수행 / 독립적인 개념 스키마 설계
- 논리적 설계 : 트랜잭션 인터페이스 설계 / 종속적인 논리적 스키마 설계 (독립적 x) / 목표 dbms에 맞는 스키마 설계
- 물리적 설계 : 저장 레코드의 양식을 설계 / 파일 조직 방법과 저장 방법 접근 방법을 선정 / 응답시간 저장공간 효율화 트랜잭션 처리도 / 목표 dbms에 맞는 물리적 구조의 데이터 변환 (스키마의 평가 및 정제 x / 트랜잭션 모델링 x / 목표 dbms에 맞는 스키마 설계 x / 트랜잭션 인터페이스 설계 x)


#데이터베이스 언어
	데이터 정의어 DDL (Data Define Language) : 스키마 , 도메인 , 테이블 , 뷰 , 인덱스를 정의하거나 변경 또는 삭제할 때 사용하는 언어

	- CREATE : 스키마 도메인 테이블 뷰 인덱스를 정의한다
	- ALTER : 테이블에 대한 정의를 변경하는데 사용한다
	- DROP : 스키마 도메인 테이블 뷰 인덱스를 삭제한다
	
# ㄲ	
	데이터 조작어 DML(Data Manipulation Language) : 데이터 베이스 사용자가 응용 프로그램이나 질의	어를 통하여 저장된 데이터를 실질적으로 처리하는데 사용되는 언어이다

	-  SELECT : 테이블에서 조건에 맞는 튜플을 검색한다.
	-  INSERT : 테이블에 새로운 튜플을 삽입한다
	-  DELETE : 테이블에서 조건에 맞는 튜플을 삭제한다.
	-  UPDATE : 테이블에거 조건에 맞는 튜플의 내용을 변경한다.
#ㄲ


	데이터 제어어 DCL(Data Control Language) : 데이터의 보안 무결성 회복 병행 수행 제어들을 정의하	는데 사용되는 언어

	- COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려준다.
	- ROLLBACK : 데이ㅓ베이스 조작 작업이 비종상적으로 종료되었을 때 원래의 상태로 복구한다.
	- GRANT : 데이터베ㅣ스 사용자에게 사용 권한을 부여한다
	- REVOKE : 데이터베이스 사용자의 사용 권한을 취소한다




#스키마

정의

- 스키마는 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한다
- 스키마는 데이터베이스를 구성하는 데이터 개체 속성 관계 및 데이터 조작시 데이터 값들이 갖는 제약조건 등에 관해 전반적으로 정의한다
- 스키마는 사용자의 관점에 따라 외부 스키마 , 개념 스키마, 내부 스키마로 나뉜다.

특징

- 스키마는 데이터 사전에 저장된다
- 스키마는 현실 세계의 특정한 한 부분의 표현으로서 특정 데이터 모델을 이용해서 만들어진다
- 스키마는 시간에 따라 불변인 특성을 갖는다
- 스키마는 데이터의 구조적 특성을 의미하며 인스턴스에 의해 규정된다

#로킹
- 로킹은 주요 데이터의 액세스를 상호 배타적으로 운영하는 것이다
- 로킹 단위는 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미한다
- 데이터베이스 파일 레코드 등은 로킹 단위가 될 수 있다



#데이터베이스의 정의
- 통합된 데이터 Integrated Data
- 저장된 데이터 Stored Data
- 운영 데이터 Operational Data : 조직의 업무를 수행하는데 없어서는 안될 반드시 필요한 자료
- 공용 데이터 Shared Data : 여러 응용 시스템들이 공동으로 소유

# 스키마의 3계층
외부 스키마 = 서브 스키마 = 사용자 뷰

- 외부 스키마는 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
- 외부 스키마는 전체 데이터베이스의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마라고도 한다.
- 하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있으며, 하나의 외부 스키마를 여러 개의 응용 프로그램이나 사용자가 공용할 수도 있다
- 같은 데이터베이스에 대해서도 서로 다른 관점을 정의할 수 있도록 허용한다.
- 일반 사용자는 질이의를 이용하면 디비를 쉽게 사용할 수 있다
- 응용 프로그래머는 코볼 씨 등의 언어를 사용하여 디비에 접근한다  



개념 스키마 = 전체적인 뷰

- 개념 스키마는 데이터베이스의 전체적인 논리적 구조로서 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재한다.
- 개념 싀마는 개체간의 관계와 제약 조건을 나타내고 데이터베이스의 접근 궈한 보안 및 무결성 규칙에 관한 명세를 정의한다
- 단순히 스키마 라고하면 개념 스키마를 의미한다.
- 기관이나 조직체의 관점에서 데이터베이스를 정의한것
- 데이터베이스 관리자 (DBA) 에 의해서 구성된다.


내부 스키마

- 내부 스키마는 데이터베이스의 물리적 구조이다.
- 내부 스키마는 데이터의 실제 저장 방법을 기술한다.
- 물리적인 저장장치와 밀접한 계층이다
- 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마

#sql문

- select : 속성명 or 테이블명.속성명 or *
- from : 테이블명
- where : 조건
- group by : 특정 속성을 기중으로 그룹화하며 검색할때 그룹화할 속성
- having : group by와 함께 사용 그룹에 대한 조건을 지정
- order by : 속성을 기준으로 정렬 / 속성 asc:오름차순 desc:내림차순
- distinct : 중복제거

#함수적 종속 관계
학번에 따라 이름이 결정될 때 이름을 학번에 함수 종속적이라고 한다

학번->이름 으로 표현한다.   이때 학번에 대해서 반드시 하나의 이름값이 연관된다

#트리 읽기
트리의 차수 : 가장 차수가 많은 노드의 차수
터미널 노드 : 자식이 하나도 없는 노드 

#개체 관계 모델 (E-R Model)
개념적 데이터 모델의 가장 대표로 1976년 피터 첸에 의해 제안된 이래 개체와 개체간의 관계를 기본 요소로 이용하여 현실 시계의 무질서한 데이터를 개념적이 논리 데이터로 표현하기 위한 방법으로 많이 사용되고 있다

특징

- 이알 모델은 개체타입과 이들간의 관계타입을 이용해 현실 세계를 개념적으로 표현한다
- 이알 모델에서는 데이터를 개체 관계 속성으로 묘사한다
- 이알 모델은 특정 dbms를 고려한 것은 ㅇ니다
- 최초의 엔티티 릴레이션 애트리뷰트 와 같은 개념으로 구성되었으나 나중에는 일반화 계층 같은 복잡한 개념들이 첨가되어 확장된 모델로 발전했다

#데이터 모델의 구성요소
- 구조(structure) : 논리적으로 표현된 개체들 간의 관계를 표시함
- 연산(operation) : 뎅터베이스에 저장된 실제 데이터를 처리하는 방법을 표시함
- 제약조건(constrain) : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 표시함

#릴레이션의 특징

- 한 릴레이션에 포함된 튜플들은 모두 상이하다
- 한 릴레이션에 포함된 튜플 사이에는 순서가 없다
- 튜플들의 삽입 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다
- 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다
- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만 속성을 구성하는 값은 동일한 값이 있을 수 이싸
- 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분ㄷ집합을 키로 설정한다
- 속성은 더 이상 쪼갤 수 없는 원자값만을 지정한다 (학년에 저장된 1,2,4 등은 더 쪼갤 수 없다)

#색인 순차 파일
- 순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키값순으로 정렬시켜 기록하고 레코드의 키 항목만을 모은 색인을 구성하여 편성하는 방식
- 색인을 이용한 순차적인 접근 방법을 제공하여 ISAM (Index Sequetial Access Method)라고 함
- 레코드를 참조할 때 색인을 탐색한 후 색인이 가리키는 포인터를 사용하여 직접 참조할 수 있다
- 일반적으로 자기 디스크에 많이 사용되며 자기 테이프에서는 사용할 수 없다

구성

- 기본구역(prime area) : 실제 레코드들을 기록하는 부분으로 각 레코드는 키값순으로 저장됨
- 색인 구역(index area) : 기본 구역에 있는 레코드들의 위치를 찾아가는 색인이 기록되는 부분으로 트랙 색인 구역 , 실린더 새긴 구역, 마슽 색인 구역으로 구분할 수 있음
- 오버플로 구역 : 기본 구역에 ㅣㄴ 공간이 없어서 새로운 레코드의 삽입이 불가능할 때를 대비하여 에비적으로 확보해 둔 부분 / 실린더 오버플로 구역 : 각 실린더마다 만들어지는 오버플로 구역 실린더의 기본 구역에서 오버플로된 데이터를 기록 / 독립 오버플로 구역 : 실린더 오버플로 구역에 더 이상 오버플로된 데이터를 기록할 수 없을 때 사용할 수 있는 예비 공간으로 실린더 오버플로 구역과는 별도로 만들어짐

문제

- 순차 처리와 직접 처리가 모두 가능하다
- 레코드를 추가 및 삽입하는 경우, 파일 전체를 복사할 필요가 없다
- 색인 구역은 트랙색인구역 실린더색인구역 마스터색인구역으로 구성된다.


-----------

#전자계산기 구조


#플린(flynn)의 병렬 컴퓨터 분류

- SISD(Single Instruction stream Single Data Stream) : 한개의 명령으로 한개의 자료 처리
- SIMD(Single Instruction stream Multi Data stream) :  한 개의 명령으로 여러 자료 처리
- MISD(Multi Instruction stream Single Data stream) : 여러 개의 명령으로 한개의 자료 처리
- MIMD(Multi Instruction stream Multi Data stream) : 여러 개의 명령으로 여러 개의 자료 처리

#순서 논리회로 / 조합 논리 회로

순서논리회로

- 논리 게이트 외에 메모리 요소와 귀한(피드백)기능을 포함
- 출력은 현재 상태와 입력상태와 전 상태에 의해 결정되므로 언제가 일정한 값을 갖니는 않음
- 회로의 동작은 내부 상태와 입력 등의 시간 순차에 의해 결정

예 : 플립플롭 , 카운터 , 레지스터, 램, 씨피유

조합논리회로

예 : 반가산기 전가산기 병렬가산기 반감산기 전감산기 디코더 인코더 멀티플렉서 디멀티플렉서 다수결회로 비교기 등


#주요명령의 마이크로 오퍼레이션
AND AC(AC는 누산기) 
- MAR<-MBR(ADDR)
- MBR<-M[MAR]
- AC<-AC ^(논리곱) MBR

ADD 
- MAR<-MBR[AD]
- MBR<-M[MAR]
- AC<-AC+MBR

Load to AC
- MAR<-MBR[AD]
- MBR<-M[MAR] , AC <-0
- AC<-AC+MBR == (AC<-MBR)

Store AC
- MAR<-MBR[AD]
- MBR<-AC
- M[MAR]<-MBR

Branch UNcondiotionally
- PC<-MBR[AD]


특징

- 마이크로 오퍼레이션은 instruction을 수행하기 위해 ㅣㅆ피유 내의 레지스터와 플래그가 의미있는 상태 변환을 하도록 하는 동작
- 마이크로 오퍼레이션은 레지스터에 저장된 데이터에 의해 이루어지는 ㄷㅇ작
- 마이크로 오퍼레이션은 한개의 클락펄스 동안 실행되는 기본 동작
- 마이크로 오퍼레이션은 컴퓨터의 모든 명령을 구성하고 있는 몇가지 종류의 기본 동작
- 마이크로 오퍼레이션의 순서를 결정하기 위하여 제어장치가 발생하는 신호를 제어 신호라고 한다
- 한개의 인스트럭션은 여러개의 마이크로 오퍼레이션이 동작되어 실행된다

문제

- 마이크로 오퍼레이션은 시피유 내의 레지스터들과 연상장치에 의해서 이루어진다
- 프로그램에 의한 명령의 수행은 마이크로 오퍼레이션의 수행으로 이루어진다
- 마이크로 오퍼레이션이 실행될 때 마다 시피유 내부의 상태는 변하게 된다
- 인덱스 레지스터는 프로그램의 레지스터의 내용을 변경할 수 있지만 연산 레지스터의 내용은 변경할 수 없다



#스택 인스트럭션은 명령어 형식에 비해 인스트럭션 수행시간이 짧다

#마이크로 명령의 형식

- 수직 마이크로 명령 /
- 수평 마이크로 명령 /
- 나노 명령 

#다음 소자 중에서 Rom과 유사한 성격을 가지며 AND ARRay 와 OR array로 구성된 것은?

PLA (programmable logic array)

#불 대수 기본 공식

 책 참고
 
 
#연산 명령 자체로 특수한 곱셈과 나눗셈을 수행하거나 혹은 이에 보조적으로 이용되는 것

산술적 shift


#기억장치 용량이 1M워드 32비트 일때 PC MAR MBR의 비트 수

- PC와 MAR은 워드의 수를 모두 지정할 수 있는 크기의 비트가 필요하고 MBR은 1워드의 크기와 같다
- PC의 비트 수가 n이면 2의 N승개의 기억 장소를 지정할 수 있스니다 1m=2^20 이므로 pc와 mar의 길이는 20비트로 구성되어야 합니다
- 워드의 길이가 32비트이므로 MBR은 32비트 *주소선의 수 = pc의 비트수 = mar의 비트 수
- data bus의 비트수  = mbr의 ㅣ트수 = ir의 비트수

#계산에 의한 주소방식

약식 주소 = 계산에 의한 주소

- 상대주소(Relative Mode) : 유효주소-명령어의 주소 부분 + PC / 명령어 자신의 기억 장소를 기준으로 하여 데이터의 위치를 지정하는 방식
- 베이스 레지스터 : 유효주소-명령어의 주소부분 + 베이스 레지스터 / 프ㅗ그램을 재배치 할때 이용한다
- 인덱스 레지스터 : 유효주소-명령어의 주소 부분 + 인덱스 레지스터

#오류 검출용 코드

- 패리티 검사코드 : 패리티 검사 코드는 코드의 오류를 검사하기 위해서 데이터비트외에 1비트의 패리티 체크 비트를 추가하는 것으로 1비트의 오류만 검출할 수 있다 / 1의 개수에 따라 짝수 패리티와 홀수 패리티 방법이 있다 / 홀수(짝수) 패리티(Odd Parity) : odd(even) 패리티는 코드에서 1인 비트의 수가 홀수(짝수)가 되도록 0이나 1을 추가함 


해밍코드

- 해밍코드느 오류를 스스로 검출하여 교정이 가능한 코드
- 해밍 코드는 2비트의 오류를 검출할 수 있고 1비트의 오류를 교정할 수 있다
- 데이터 비트 외에 오류 검출 및 교정을 위한 잉여 비트가 많이 ㅂ필요하다
- 해밍 코드 중 1 2 4 8 16 ...2^n 번째는 오류 검출을 위한 패리티 비트이다

- biquinary 코드


#2의 보수 가산 회로로서 정수 곱셈을 이행할 경우 필요 없는 것

normalize

#주기억장치는 하드웨엉 특성상 제공할수 있는 정보 전달 능력에 한계가 있는데 이를 주기억장치 대역폭이라한다

대역폭 Bandwidth

- 대역폭은 메모리로부터 또는 메모리까지 1초동안 저송되는 최대한의 정보량으로 기억장치의 자료 처리 속도를 나타내는 단위
- 대역폭은 물리적으로 버스의 크기에 영향을 받는다

#	보조기억장치의 일반적 특징
- 중앙처리장치와 직접 자료 교환이 불가능하다
- 접근시간이 크다
- 일반적으로 주기억장치에 데이터를 저장할 때는 dma 방식을 이용한다
- cpu와 보조기억장치는 직접 자료교환이 불가능하다

#각 명령어 형식에서 자료 저장 장소로 사용하는 기억 장소
- 0주소 명령어 :  스택
- 1주소 명령어 : 누산기
- 2주소 명령어 : 범용 레지스터
- 3주소 명령어 : 범용 레지스터

문제

명령문 구성 형태 중 하나의 오퍼랜드가 누산기 속에 포함 된 명령 형식은? 1주소 명령어

#메모리 인터리빙
- 인터리빙이란 여러 개의 독립된 모듈로 이루어진 복수 모듈 메모리와 CPU간의 주소 버스가 한 개로만 구성되어 있으면 같은 시각에  CPU로 부터 여러 모듈들로 동시에 주소를 전달할 수 없기 때문에 씨피유가 각 모듈로 전송할 주소를 교대로 배치한 후 차례대로 전송하여 여러 모듈을 병행 접근하는 기법
- 시피유가 버스를 통해 주소를 전달하는 속도는 빠르지만 메모리 모듈의 처리속도가 느리기 때문에 병행 접근이 가능하다
- 메모리 인터리빙 기법을 사용하면 기억장치의 접근시간을 효율적으로 높일수있으므로 캐시기억장치 고속 dma전송등에 많이 사용된다

#주소 설계시 고려해야할 사항
- 표현의 효율성 : 빠르게 접근하고 주소 지정에 적은 비트 수를 사용할 수 있도록 다양한 어드레스 모드를 사용할수 있어야함
- 사용의 편리성 : 다양하고 융통성 있는 프로그램 작업을 위해 포인터 프로그램 로케이션등의 편의를 제공하여야함
- 주소공간과 기억공간의 독립성 : 프로그램 상에서 사용한 주소를 변경 없이 실제 기억 공간내의 주소로 재배치할수있도록 서로 독ㅂ적이어야함

문제

- 주소를 효율적으로 나타낼수있어야한다
- 주소 공간과 기억공간을 독립시킬수 있어야한다
- 전반적으로 수행속도가 증가될수있도록 해야한다


----------



#운영체제

#하이퍼 큐브
연걸점이 n개인 경우 프로세서는 2^n

#프로세스의 정의
- 실행중인 프로그램
- pcb를 가진 프로그램
- 실기억장치에 저장된 프로그램
- 프로세서가 할당되는 실체
- 프로시저가 활동중인 것
- 비동기적 행위를 일으키는 주체
- 지정된 결과를 얻기 위한 일련의 계통적 동작
- 목적 또는 결과에 따라 발생되는 사건들의 과정

문제
- 프로세서가 할당하는 개체로서 디스패치가 가능한 단위


#운영체제의 목적
- 처리 능력(Throughput) : 일정 시간 내에 시스템이 처리하는 일의 양
- 반환 시간(Turn Around Time) : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때 까지 걸린 시간
- 사용 가능도(Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
- 신뢰도(Reliability) : 시스템이 주어진 문제를 정확하게 해결하는 정도


#커널 / 쉘

커널

- unix의 가장 핵심적인 부분이다
- 컴퓨터가 부팅될 때 주기억장치에 적대된 후 상주하면서 실행된다
- 하드웨어를 보호하고 프로그램과 하드웨어 간의 인터페이스 역할을 담당한다
- 프로세스 관리 기억장치 관리 파일관리 입출력관리 프로세스간 통신 데이터전송 및 변환 등 여러가지 기능을 수행한다

쉘

- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기이다.
- 시스템과 사용자 간의 인터페이스를 담당한다
- dos의 command.com과 같은 기능을 수행한다
- 주기억장치에 상주하지 않고 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체처리가 가능하다
- 공용 쉘 (bourne shell,  c shell korn shell)이나 사용자 자신이 만든 쉘을 사용할 수 있다


명렁어 해석기 는 쉘   자원 관리는 커널


문제<유닉스에 대한 옳은 설명>
- 두사람 이상의 사용자가 동시에 시스템을 사용할 수 있어 정보와 유틸리티들을 공유하는 편리한 작업 환경을 제공한다
- 상당 부분 c언어를 사용하여 작성되었으며 이식성이 우수하다
- 사용자는 하나 이상의 작업을 백그라운드에서 수행할 수 있어 여러개의 작업을 병행 처리할 수 있다



#페이징 기법 / 세그먼테이션 기법
페이징 기법

- 가상기억장치에 보관되어 있는 프로그램과 주기억장치에 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 ㅈ실행하는 기법
- 프로그램을 일정한 크기로 나눈 단위를 페이지라고하고 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임이라고한다
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다 *단편화 기억장치의 빈공간이 생겨 공간이 낭비됨
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다
- 페이지 맵 테이블 사용으로 비용이 증가되고 처리 속도가 감소된다
- 

세그먼테이션 기법

- 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
- 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며 각 세그먼트는 고유한 이름과 크기를 갖는다
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법이다
- 세그먼테이션 기법을 이용하는 궁극적인 이유는 기억 공간을 절약하기 위해서 이다
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요하다
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며 이를 위해 기억장치 보호키가 필요하다



#운영체제의 역할

- 프로세서 기억장치 입출력장치 파일 및 정보등의 자원을 관리한다
- 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공한다
- 사용자와 시스템간의 편리한 인터페이스를 제공한다
- 시스템의 각종 하드웨어와 네트워크를 관리 제어한다
- 데이터를 관리하고 데이터 및 자원의 공유기능을 제공한다
- 시스템의 오류를 검사하고 복구한다
- 자원 보호 기능을 제공한다
- 입출력에 대한 보조 기능을 제공한다
- 가상 계산기 기능을 제공한다

문제
- 옳은 것
- 사용자와 시스템간의 편리한 인터페이스를 제공한다
- 자원의 효과적인 경영을 위해 스케쥴링 기능을 제공한다
- 여러 사용자들 사이의 자원의 공유를 가능하게 한다

#HRN 기법의 우선순위 공식


(대기시간 + 서비스 시간) / (서비스 시간)

숫자가 큸록 우선순위가 높다

# unix명령어

- fork : 새로운 프로세스를 생성 프로세스를 복제
- chmod : 파일에 대한 액세스 권한을 설정하여 사용자에게 제한적 권한을 줌
- chown : 파일의 소유자를 변경
- wait: 자식 프로세스의 하나가 종료될 때까지 부모 프로세스 임시 중기
- mount: 기존 파일 시스템에 새로운 파일 시스템을 서브 디렉터리에 연결
- cp: 파일 복사
- mv : 파일 이동 및 이름 변경
- rm : 파일 삭제 
- cat : 파일 내용을 화면에 표시
- getppod : 자식 프로세스의 아이디를 얻음
- fsck : 파일 시스템을 검사 보수하여 무결성을 검사
- finger : 사용자의 정보를 표시
- ls ; 현재 디렉터리내의 파일목록확인

#라운드 로빈

라운드 로빈방식은 여러명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아 가며 처리해줌으로써 각 사용자는 독립된 컴퓨터를 사용하는 것 처럼 느끼는 것으로 시분할 시스템이다 (Time sharing system)



#페이지 교체 알고리즘

페이지 교체는 참조 페이지가 페이지 테이블에 없을 겨우 발생한다!


FIFO

- 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
- 벨레이디의 모순이현상이 발생 = 페이지 프레임 수가 많으면 부재가 줄어드는 것이 일반적이지만 프레임 수를 증가시켜도 페이지 부재가 더 많이 일어나는 현상

LRU(Least Recently Used)

- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법

#워킹셋

- 워킹 셋은 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합이다
- 데닝이 제안한 프로그램의 움직임에 대한 모델로 프로그램의 locality특징을 이용한다
- 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상을 줄인다
- 프로세스가 실행하는 과정에서 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 바뀌게 된다
- 워킹 셋에 속한 페이지를 참조하면 프로세스의 기억장치 사용은 안정상태가 된다

#주/종 프로세서

주 프로세서

- 입 출력과 연산을 담당한다
- 운영체제를 수행한다

종 프로세서

- 연산만 담당한다
- 입 출력 발생 시 주 프로세서에게 서비스를 요청한다
- 사용자 프로그램만 담당한다



문제

- 주 프로세서가 운영체제를 수행한다
- 주 프로세서가 고장이나면 시스템 전체가 다운된다
- 하나의 프로세서를 주 프로세서로 지정하고 다른 처리기들은 종프로세서로 지정하는 구조이다
- 주 프로세서만 입 출력을 수행하기 때문에 비대칭 구조를 갖는다

#PCB에 저장되어 있는 정보

- 프로세스의 현재상태 :  준비 대기 실행등의 프로세스 상태
- 포인터 : 부모 프로세스에 대한 포인터 자식 프로세스에 대한 포인터 프로세스가 위치한 메모리에 대한 포인터 할당된 자원에 대한 포인터
- 프로세스 고유 식별자 : 프로세스를 구분할 수 있는 고유의 번호
- 스케줄링 및 프로세스의 우선순위 ; 스케줄링 정보 및 프로세스가 실행될 우선 순위
- cpu레지스터 정보
- 주기억장치관리정보

문제 

- 프로세스의 제어블록에 대한 설명 (process control block)
- 프로세스에 할당된 자원에 대한 정보를 갖고 있다
- 프로세스의 우선 순위에 대한 정보를 갖고 있다
- 프로세스의 현 상태를 알 수 있다
- 프로세스가 생성될 떄마다 고유의 pcb가 생성되므로 부모와 자긱 각각 다른 블록을 사용

#배치 전략

- 최초적합 (First-Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법
- 최적적합 (Best-Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
- 최악적합(Worst-Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법

#inode에 포함된 정보

- 파일 소유자의 사용 번호 및 그룹 번호
- 파일 크기
- 파일 유형
- 생성 시기
- 최종 변경 시기
- 최근 사용 시기
- 파일의 보호 권한
- 파일 링크 수
- 데이터가 저장된 블록의 시작 주소

문제에 자주 등장하는 포함되지 않는 정보

- 파일이 사용된 횟수
- 파일이 최초로 수정된 시간
- 파일 경로명 등


#디스크 스케줄링 기법

- FCFS(First Come First Service) : 가장 간단한 스케줄링으로 디스크 대기 큐에 가자 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법
- SSTF(Shortest Seek Time First) : 탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법
- SCAN : SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법으로 현재 헤드의 위치에서 진행 방향이 결정되면 탐색 거리가 짧은 순ㅅ에 따라 그 방향의 모든 요청을 서비스하고 끝까지 이동한 후 역방향의 요청 사항을 서비스 함
- N-Step SCAN : SCAN 기법을 기초로 하여 어떤 방향의 진행이 시작될 당시에 대기 중이던 요청들만 서비스하고 진행 도중 도착한 요청들은 한데 모아서 다음의 반대 방향 진행 때 서비스하는 기법
- 에센바흐 기법 (Eschenbach) : 부하가 매우 큰 항공 예약 시스템을 위해 개발되었으며 탐색 시간과 회전 지역 시간을 최적화하기 위한 최초의 기법
- SLTF(Shortest Latenct Time First) :  섹터큐잉 이라고 하며 회전 시간의 최적화를 위해 구현된 기법

#쓰레드
- 프로세스내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프ㅗ그램 단위
- 하나의 프로세스에 하나의 스레드일경우 단일 스레드  하나이상일 경우 다중 스레드라고 한다
- 경량 프로세스라고도 한다
- 자신만의 스택과 레지스터를 가지며 독립된 제어 흐름을 갖는다

스레드의 분류

사용자 수준의 스레드

- 사용자가 만든 랑브러리를 사용하여 스레드를 운용한다
- 속도는 빠르지만 구현이 어렵다

커널수준의스레드 

- 운영체제의 커널에 의해 스레드를 운용한다
- 구현이 쉽지만 속도가 느리다

#디렉터리 구조

- 1단계 디렉터리 : 가장 간단한 형태로 모든 파일이 하나의 디렉터리 내에 위치하여 관리되는 구조
- 2단게 디렉터리 : 중앙에 마스터 파일 디렉터리가 있고 그 아래에 사용자별로 서로 다른 파일 디렉터리가 있는 2계층 구조
- 트리 구조 디렉터리 : 하나의 루트 디렉터리와 여러 개의 종속 디렉터리로 구성된 구조
- 비순환 그래프 디렉터리 : 하위 파일이나 하위 디렉터리를 공동으로 사용할 수 있는 것으로 사이클이 허용되지 않는 구조 = 하위 디렉터리가 상위 디렉터리나 상위 파일을 공유할수없는것
- 일반 그래프 디렉터리 : 트리 구조에 링크를 첨가시켜 순환을 허용하는 그래프 구조

#분산 운영체제의 구조

- 망형 완전 연결 (Fully Connection) 형 :각 사이트들이 시스템 내의 다른 모든 사이트들과 직접 연결된 구조
- 망형 부분 연결 (Partically Connection) 형 : 시스템 내의 일부 사이트들 간에만 직접 연결하는 것으로 직접 연결되지 않은 사이트는 연결된 다른 사이트를 통해 통신하는 구조
- 트리 또는 계층형 : 분산 처리 시스템의 가장 대표적인 형태로 각 사이트들이 트리 형태로 연결된 구조
- 스타형 = 성형 : 모든 사이트나 하나의 중앙 사이트에 직접 연결되어 있고 그외 다른 사이트와는 연결되어 있지 않은 구조
- 링형 = 환형 : 시스템 내의 각 사이트가 인접하는 다른 두 사이트와만 직접 연결된 구조

---------



#소프트웨어 공학

#럼바우의 omt 모델링

- 객체 모델링(오브젝트 모델링) : 실세계 문제 영역으로부터 시스템에 요구되는 객체를 찾아내어 객체들 간의 관계를 규정하여 객체 다이어그램으로 나타내는 것
- 동적 모델링(다이나믹 모델링) : 시간의 흐름에 따라 변하는 객체들 사이의 제어 흐름, 상호 작용, 연산 순서 등의 동적인 행위를 상태 다이어그램으로 나타내는것
- 기능 모델링(펑션 모델링) : 다수 프로세스 간의 데이터 흐름을 중심으로 처리 과정을 자료 흐름도로 나타내는것

#소프트웨어 위기 발생요인

- 소프트웨어 개발 적체 현상
- 프로젝트 개발 일정과 예산 측정의 어려움
- 소프트웨어 생산성 기술의 낙후
- 소프트웨어의 수요가 증가하고 있는 상황에서 개발 이용의 증대 개발 기술자 부족 프로젝트 관리 ㅅ기술의 부재 프로그래밍에만 치중되는 행위 등이 위기의 원인

#나선형 모형

- 보헴이 제안한 것으로 폭포수 모형과 프로토타입 모형의 장점에 위험분석 기능을 추가한 모형
- 나선을 따라 돌듯이 여러번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것으로 점진적 모형이라고도 한다
- 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다

개발 순서

1. 계획 및 정의  : 개발 목적 제약 조건등을 설정한다
2. 위험 분석 : 위험 요소를 분석하고 기능 선택의 우선 순위를 지정한다
3. 공학적 개발 : 개선된 한 단계 높은 수준의 프로토타입을 개발한다
4. 고객 평가 : 개발된 결과(프로토타입)을 평가한다

특징

- 가장 현실적인 모형으로 대규모 프로젝트나 큰 시스템에 적합한다
- 점진적으로 개발 과정이 반복되므로 누락되거나 추가된 요구사항을 첨가할 수 있고 정밀하며 유지보수 과정이 필요없다


문제 나선형에 대해 옳지 않은 것

1. 대규모 시스템에 소프트웨어 개발에 적합다
2. 실제 개발될 소프트웨어에 대한 시제품을 만들어 최종 결과물을 예측한다 - 프로토타입
3. 위험성 평가에 크게 의존하기 때문에 이를 발견하지 않으면 문제가 발생할 수 있다
4. 여러번의 개발과저을 거쳐 점진적으로 완벽한 소프트웨어를 개발한다


#소프트웨어의 품질목표

- 정확성 Correctness : 사용자의 요구 기능을 충족시키는 정도
- 신뢰성 Realiability : 정확하고 일관된 결과를 얻기 위해 요구된 긴으을 오류 ㅎ없이 수행하는 정도
- 효율성 Efficiency : 요구되는 기능을 수행하기 위해 필요한 자원으ㅏㅣ 소요 정도
- 무결성 Integrity : 허용도지 않는 사용이나 자료의 변겨을 제어하는 정도
- 용이성 Usability ; 사용에 필요한 노력을 최소화하고 쉽게 사용할 수 있는 정도
- 유지보수성 Maintainability : 변경 및 오류 사항의 수정에 대한 노력을 최소화ㅅ하는 정도
- 유연성 Flexibility : 소프트웨어를 얼마만큼 쉽게 수정할 수 있는 가 하는 정도
- 시험역랑 Testability : 의도된 기능을 수행하도록 보장하기 위해 프로그램을 시험할 수 있는 정도
- 이식성 Portability : 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 정도
- 상호운용성 Interoperability : 다른 소프트웨어와 정보를 교환할 수 있는 정도


#역공학

- 기존 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리과정을설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어 내는 작업이다.
- 정공학 과는 반대 방향으로 기존 코드를 복구하는 방법이다.
- 대상 소프트웨어가 있어야 하며 이로부터 작업이 시작된다
- 기존 소프트웨어의 구성 요소와 그 관계를 파악하여 설계도를 추출하거나 구현과는 독립적인 추상화된 표현을 만든다
- 코드 역공학 : 코드->흐름도->자료구조도->자료 흐름도 순으로 재생함
- 데이터 역공학: 코드->자료 사전->개체 관계도 순으로 재생함
- 역공학의 가장 간단하고 오래된 형태는 재문서화


역공학은 원시 코드로부터 설계정보 추출및 설계절차 표현, 프로그램 과 데이터 구조 정보를 추출하는 것



#정형 기술 검토(FTR : formal technical review)의 지침 사항

- 제품의 검토에만 집중하라
- 문제 영역을 명확히 표현하라
- 해결책이나 개선책에 대해서는 논하지 마라
- 참가자의 수를 제한하고 사전 준비를 강요하라
- 자원가 시간 일정을 할당하라
- 모든 검토자들을 위해 의미 있는 훈련을 행하라
- 검토자들은 사전에 작성한 메모들을 공유하라
- 검토의 과정과 결과를 재검토하라

문제 논쟁과 반박을 제한해야 한다

#














