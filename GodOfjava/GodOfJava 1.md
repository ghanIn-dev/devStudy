#자바의 신 1권

## System.out.println 과 System.out.print 의 차이


println은 줄을 바꿀때 사용 print는 줄을 바꾸고 싶지 않을 때 사용한다


##문서용 주석 /**  */ 찾아보기

-
-
-

-
##기본 생성자는 자바에서 생성해준다

public class Human{

	public Human();

}

## 클래스와 객체의 차이점을 설명하시오

 클래스를 통해서 객체를 생성할 수 있다. 즉, 하나의 클래스를 만들면 그 클래스의 모습을 갖는 여러 객체들을 생성 할 수 있다. 그러므로, 일반적인 경우 클래스의 메소드나 변수들을 사용하려면 객체를 생성하여 사용하여야 한다.
 
 클래스를 통해서 객페를 생성할 수 있다 즉 하나의 클래스를 만들면 그 클랫의 모습을 갖는 여러 객체들을 생성할 수 있다 그러므로 일반적인 경우 클래스의 메소드나 변수들을 사용하려면 객체를 생성하여 사용하여야 한다.
 


## public void main(String [] args)

 main() 메소드 선언문에서 args 는 변수이며 다른 이름으로 대체하여도 상관없다
 
 
##변수의 종류는 총 4종류
* 지역 변수 "중괄호 내에서 선언되며 그 내에서만 유효하다"
* 매개 변수 " 메소드나 생성자에 넘겨주는 변수이며 메소드가 호출될 때 생명주기가 시작 끝나면 소멸 (일단은)"
* 인스턴스 변수 "메소드밖에 클래스 안에 선언된 변수로 static 이라는 예약어가 없어야한다 객체생성시 생명주기가 시작되고 그 객체를 참고잇는 다른 객체가 없으면 소멸"
* 클래스 변수  "인스턴스 변수와 위치는 같지만 앞에 static 이 붙는다. 클래스가 생성될때 생명주기 시작 자바 프로그램이 끝날 때 소멸"
   
   
##변수의 이름 짓기
* 첫문자는 소문자 두번째 단어의 첫 문자만 대문자
* 상수 즉 절대 변하지 않는 값의 경우 모두 대문자로 지정하며 단어 사이에 _를 입력한다

##자바의 자료형은 2가지가 존재한다
기본자료형고 참조자료형으로 나뉘는데 초기화할때 new 예약어를 사용하면 참조자료형 그렇지 않으면 기본자료형이라고한다.

* 단,  String의 경우 참조자료형이지만 new 예약어 없이도 사용이 가능하다.
* String bookName="ffff"  와 String bookName=new String("dfdfd")는 같다


##기본 자료형은 총 8개
* 정수형 : byte , short , int , long , char
* 소수형 : float , double
* 기타 : boolean

bsil fd (비실한 fd) 로 암기 이는 타입의 범위 순서를 나타잼

byte는 -128~127 = - 2^8-1(7) ~ 2^8-1 -1
short는 			= - 2^16-1(15) ~ 2^16-1 -1

각 타입의 나타낼 수 있는 숫자의 크기가 2배씩 증가한다.

##지역 변수는 반드시 초기화를 해야한다
단 지역변수를 메소드내에서 사용하지 않을때는 상관없다

##변수의 종류는 변수를 선언한 위치와 static 선언 여부에 따라 달라진다



## AND 연산자 $$ 는 둘다 만족  OR 연산자 || 는 둘중 하나만 만족해도  true

=========================================
##삼항연산자 (조건)? true:false
==========================================
##switch 블록에서는 long 을 제외한 정수 및 enum을 사용할 수 있으며 string 도 사용 가능하다
=========================================

##int [] array = new int [5]
##int [] array;    array = new int [5]


##만약에 int[]array=new int [1]이면 array[0]만 존재

======

##int twodim[][]에서  twodim[0]은 int 값이 아니라 배열이다. 이것 무조건 암기!!!!


## 2차원의 배열의 공간의 크기를 다르게 지정하는 것도 가능하다

##기본자료형에서는 절대  .  을 찍을 수 없다 따라서 twoDim[0}[0] 

===

##배열을 위한 for 루프 

for(타입이름 임시변수명 : 반복대상객체){

}

  
  
  
  
# 자바의 신 객체지향 편

##생성자
  
  생성자는 클래스의 객체를 만들기 위해 존재하며 매개변수가 있는 생성자를 만들고 매개변수가 없는 기본 생성자를 호출하게 되면 컴파일 에러가 발생한다
  

##DTO
자바의 패턴 중 DTO 라는 것이 있다 Data Transfer Object로 데이터ㅏ 포함된 객체를 한 시스템에서 다른 시스템으로 전달하는 작업을 처리하는 객체를 말한다.  VO (Value Object)와 거의 동일한 개념으로 사용한다

##Overloading

Overload는 과적하다 많은 부하를 주다 와 같이 해석되며 이는 

메소는 이름을 같도록하고 매개변수만을 다르게 하는 것을 말한다 

같은 역할은 같은 메소드이름을 사용한다 라는 모토를 생각

##static

static 메소드는 객체 생성 없이 호출이 가능하지만 클래스 변수만을 사용하는 단점을 가지고 있다
절대  static 을 남용해서는 안된다

static {}  ------ static블록은 생성자보다 먼저 클래스 참조시 바로 한번 실행되는 것


##pass by value 와 pass by reference

자바는 기본적으로 값에 의한 전달 pass by value를 사용하지만 객체일 경우 객체의 참조가 값으로 전달된다
즉 pass by reference

모든 기본 자료형과 참조 자료형은 매개변수로 넘어갈 때 값이 넘어가는 Pass by Value이다. 
단, 참조 자료형 안에 있는 변수들은 매개변수로 넘어갈 때 참조가 넘어가는 Pass by Reference 이다. 

##매개변수의 수를 모를때

public void Param(int...param)

##패키지

패키지는 java 시작하면 안되며

모두 소문자로 지정해야하며

예약어를 사용할 수 없다

import를 이용하여 다른 패키지에 접근 할 수 있다.

static한 변수와 메소드의 경우 import static을 사용하며 *를 사용하면 클래스의 모든 메소드와 변수를 사용할 수 있다.

##접근 제어자
 총 4가지
 
 public - 누구나 접근 가능
 
 protected - 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능
 
 package-private - 접근제어자가 없는 형태로 같은 패키지 내에 있을 때만 접근 가능
 
 private - 해당 클래스에서만 접근 가능
 
 
 클래스의 이름과 같은 public 클래스는 1개만 존재
 
 
##상속

extends : 확장하다

상속의 뜻을 가진 자바의 예약어이다.

UML은 개발을 할 때 사용하는 설계 도구이다.

-부모 클래스는 기본 생성자를 만들어 놓는 것 이외에 할 것이 없다.
-자식 클래스의 생성자가 호출되면 자동으로 부모 클래스의 기본 생성자가 호출된다.
-자식 클래스는 부모 클래스의 public protected로 선언된 모든 메소드와 변수를 사용할 수 있다.


부모 클래스에 기본 생성자를 제외한 매개변수를 가진 생성자가 있을 경우
자식클래스에서 부모클래스의 기본 생성자를 명시적으로 지정하는 super()를 사용한다.

명시적으로 super()를 지정하지않으면 super()가 자동으로 추가된다.

-부모 클래스에 선언된 메소드와 동일한 시크니쳐를 사용함으로써 메소드를 오버라이딩 할 수 있다.

-Polymorphism은 다형성을 의미한다. 
자식 클래스는 자신만의 "행위"를 가질 수 있지만, 부모 클래스에 선언된 메소드들도 공유 가능하다는 것을 의미한다. 
다시 말해, 부모 클래스의 타입으로 변수를 선언하고, 자식 클래스의 생성자를 사용할 경우 overriding된 메소드를 호출하면 자식 클래스에 선언된 메소드가 호출되고, 부모 클래스의 메소드도 공유 가능하다는 것을 의미한다. 


-"부모 변수명=new 자식();" 과 같이 선언하는 것은 가능하다. 
하지만 "자식 변수명=new 부모();"와 같이 선언하는 것은 불가능하다. 
왜냐하면 자식 클래스는 부모 클래스의 모든 내용을 상속 받으므로 전자와 같이 사용하는 것이 가능하지만,
후자의 경우와 같이 부모는 자식이 갖고 있는 모든 것을 갖지 못하기 때문에 불가능하다.

-실행시 형변환 관련 예외가 발생하지 않도록 하려면 "instanceof"예약어를 사용하여 검증 작업을 해야만 한다.
 instanceof의 좌측에는 확인하고자 하는 변수를, 우측에는 클래스 이름이 위치한다.
 
 
 
 
 
##모든 클래스의 부모 java.lang.Object

object 클래스의 메소드에서 가장 많이 사용하는 toString()메소드 와 equals() 

**toString()** 메소드는 다음의 경우 호출됨

-syso 메소드에 매개 변수로 들어가는 경우
-더하기 연산을 하는 경우


toString()함수는 오버라이딩을 통해 클래스의 값을 확인할 때 사용

Ex)

	public String toString(){

		return "Name"=+name;

	}	
	
	
**equals()** 메소드 또한 오버라이딩을 해서 사용해야하며 객체의 값을 비교할 때 사용한다

-오버라이딩을 하지 않고 사용하면 hashcode를 비교 즉, 주소값을 비교한다.



##인터페이스 와  abstract


사용이유

- 설계시 선언해 두면 개발할 때 기능을 구현하는 데에만 집중할 수 있다.
- 개발자의 역량에 따른 메소드의 이름과 매겨 변수 선언의 격차를 줄일 수 있다.
- 공통적인 인터페이스와 abstract 클래스를 선언해 놓으면, 선언과 구현을 구분할 수 있다.

**인터페이스**

- public interface 이름       식으로 선언하며 메소드는 바디가 있으면 안된다.
- 인터페이스를 구현하기 위한 예약어는 implements
- 인터페이스를 구현할 경우 구현한 클래스에 메소드의 몸통을 반드시 만들어주어야한다.


**abstract 클래스**
- public abstract class name 형식으로 선언
- abstract으로 선언한 메소드가 반드시 하나 이상 있어야함
- 바디가 있는 메소드가 있어도 상관없음


abstract의 탄생이유는 인터페이스외에 미리 만들어 놓아도 전혀 문제가 없는 경우 공통적인 기능을 미리 구현해 놓는 경우 abstract를 사용한다



##Final


- 클래스에 final을 선언하면 상속이 불가하다. 예로 String 클래스의 경우 더 이상 확장해서도 안되고 변경해서도 안되기 때문에 final로 선언되어있다.

- 메소드의 final을 선언하면 오버라이딩이 불가하다. 
- 변수의 final을 선언하면 "더 이상 바꿀 수 없다." 따라서 변수 생성과 동시에 초기화를 해야한다. 달 혹은 날짜 수 등 변하지 않는 값들에 대한 정의를 할 때 유용하다.


##enum

- enum 클래스의 변수를 지정할 경우 타입과 값을 지정할 필요가 없다.
- 값을 지정할때는  ONE(1), 다음과 같은 형태로 한다.
- enum 클래스의 부모는 무조건 java.lang.Enum이어야 한다 따라서 다른 클래스를 상속하면 안된다.
- enum 클래스는 package-private 와 private접근 제어자로만 생성자를 사용할 수 있다.
- compareTo() 메소드를 가장 많이 사용하며 (value1.compareTo(value2)형태) enum이 선언된 순서대로 각 상수들의 순서가 정해지는 이 순서를 비교하는 메소드이다. 같을 경우 0 앞에있으면 -위치 수 뒤에있으면 +위치 수 를 리턴한다.
- values() 메소드는 enum클래스에 선언된 상수의 목록을 배열로 리턴한다.







##Nested Class

Nested class를 만드는 이유
- 한 곳에서만 사용되는 클래스를 논리적으로 묶어서 처리할 필요가 있을 때
- 캡슐화가 하고 싶을 때 (a라는 클래스에 private 변수가 있다 이때 이 변수에 접근하고 싶은 b라는 클래스를 선언하고 이 클래스를 외부에 노출시키고 싶지 않은 경우)
- 소스의 가독성과 유지보수를 위해

**static nested class**

	- 클래스를 묶기 위해서 사용
	 
	 예) School 과 University 클래스가 있을 때 Student 클래스를 만들면 어느 클래스의 학생인지 불분		명하다 이때 School 클래스내에 static nested형식으로 학생클래스를 만들면 용도가 분명해지며 다른 		클래스에서 사용또한 불가하다. 
	 
	
	선언 방식
	public class OutClass{
		static class StaticNested{
		}
	}
	
	객체 생성
	OutClass.StaticNested staticnestedobj = new OutClass.StaticNested();
	


**Inner class & Anonymous class**

	-캡슐화를 위해 사용 = 하나의 클래스에서 어떤 공통적인 작업을 수행하는 클래스가 필요한데, 다른 클래스에서는 그 클래스가 전혀 필요가 없을 때 => GUI관련 프로그램을 개발할 때 가장 많이 사용

	선언방식
	
	public class OutClass{
		class InnerClass{
		}
	}
	
	객체 생성
	OutClass out = new Outclass();
	InnerClass inner = out.new InnerClass();
	
	
	익명클래스
	-클래스의 양을 줄여 메모리를 줄이고 코드의 가독성을 높이기 위해 사용한다
	


 Nested 클래스를 컴파일하면 "감싼클래스$Nested클래스.class"가 생성된다.


	
	



 
 
 
